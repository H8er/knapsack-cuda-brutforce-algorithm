# knapsack-cuda-brutforce-algorithm
Comparing of brutforce parallel method on GPU using CUDA against CPU consistent version


Функции на GPU:
1) T_binary:
    Создаёт бинарную таблицу размера N x 2^N, где N - количество предметов.
    По факту, таблица - одномерный массив, но при форматированном выводе,
    выглядит именно как таблица вида:
    000000000000000
    000000000000001
    000000000000010
    ---------------
    111111111111101
    111111111111110
    111111111111111

    Процесс заполнения таблицы:
    1. На CP создаётся массив длины N, в который записываются степени 2 от 0 до N
    "for (int i = 0; i < arraySize; i++) {
			del[i] = pow(2, i);
		}"
    2. Под этот массив выделяется область в глобальной памяти GPU:
            "cudaMalloc((void**)&_del, 15 * sizeof(int));"
    Этот массив копируется в выделенную память GPU
    "cudaMemcpy(_del, del, arraySize * sizeof(int), cudaMemcpyHostToDevice);"
    3. Каждый элемент массива получает значение, равное остатку от деления
    номера строки на значение степени двойки, соответствующее номеру элемента в строке:
    "bin_dev[bli + idx] = blockIdx.x / _del[idx] % 2;"
        bin_dev - таблица в памяти GPU
        bli = blockIdx.x - номер блока (строки от 0 до 2^N)
        idx - номер элемента в строке (от 0 до N)
        _del - массив степеней двойки
      По факту, заполнение данной таблицы - перевод номера строки из 10 системы
      счисления в 2, только распараллеленный с учётом особенностей индексирования CUDA.
    Массив сохраняется в глобальной памяти GPU

2)bin_multiplication
  Функция производит перемножение значений веса и стоимости предметов, на соответствующие их индексам
  значения бинарного массива.
  Таким образом, получается 2 таблицы размера N x 2^N в которых вместо 1 из бинарной таблицы,
  стоит соответствующее значение веса или стоимости.

3)summing
  Функция производит сложение значений весов или стоимостей построчно.
  Для быстродействия, используется __shared__ память GPU.
  Цикл сложения "развёрнут" через использование "#pragma unroll". "Разворачивание" цикла происходит
  во внутренней памяти каждого блока, благодаря чему не происходит конфликтов при значениях, меньших
  числа итераций цикла.
  После выполнения функции получается 2^N значений сумм весов и 2^N значений сумм стоимостей,
  которые далее необходимо проанализировать.

4)additional_summing
  Функция используется, если количество предметов равно 16. Из-за особенностей архитектуры, количество блоков,
  равное 2^16 не обрабатывается корректно, поэтому используется данная функция. Она копирует полученные ранее
  значения сумм для 15 предметов, после чего копирует их, прибавляя к этим значениям 16-е значение веса и стоимости соответственно.
  Таким образом получается 2^16 значений сумм весов и стоимостей.

5)zeroing
  Функция обнуляет неудолетворительные значения стоимостей, если соответствующий ей вес превышает
  ограничение вместимости

5)reduction_max
    Параллельный алгоритм поиска максимального значения.
    Используется "редукция ядер CUDA" и __shared__ память.
После завершения функции из 2^N значений остаётся 2^(N-10) значения стоимостей, из которых остаётся
выбрать максимальное.

6)cycle_max
  Бинарный поиск максимального значения с использованием CUDA.
  a) Использовение функции при значении "flag==1"
  Вызов 2 блоков по 32 треда. После выполнения остаётся 1 блок, состоящий из 32 значений.
  б) Вызов функции реализуется через цикл.
  "for (int i = a; i >= 1; i /= 2) {
    cycle_max << <1, i >> > (s,i);}"
    Один "варп" в CUDA состоит из 32 тредов, что позволяет выполнять функцию на одном блоке.
    На каждой итерации цикла, количество параллельных "тредов" уменьшается в 2 раза.
    Таким образом, максимальное значение находится за 5 итераций цикла
